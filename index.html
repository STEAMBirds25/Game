<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>F1: Live Calibration Tool</title>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; user-select: none; }
        
        /* DEBUG PANEL */
        #debug-panel {
            position: absolute; top: 10px; right: 10px; width: 220px;
            background: rgba(0,0,0,0.8); color: #0f0; padding: 10px;
            border: 1px solid #0f0; border-radius: 8px; font-size: 12px;
            z-index: 100; pointer-events: auto; display: flex; flex-direction: column; gap: 5px;
        }
        .debug-row { display: flex; justify-content: space-between; align-items: center; }
        input[type=range] { width: 100px; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        .controls-area { position: absolute; bottom: 0; width: 100%; height: 200px; display: flex; justify-content: space-between; padding: 20px; box-sizing: border-box; }
        .pedal { width: 80px; height: 140px; background: #333; border: 2px solid #555; pointer-events: auto; margin-top: auto; }
        #gas-pedal { border-bottom: 5px solid #0f0; }
        #brake-pedal { border-bottom: 5px solid #f00; height: 100px; }
        #steering-zone { width: 200px; height: 140px; background: rgba(255,255,255,0.1); border-radius: 20px; pointer-events: auto; }
        #speed-box { position: absolute; top: 20px; left: 20px; color: cyan; font-size: 30px; font-weight: bold; }
    </style>
</head>
<body>

    <!-- PANEL DE CALIBRACIÓN EN VIVO -->
    <div id="debug-panel">
        <h3 style="margin:0; text-align:center; border-bottom:1px solid #0f0">CALIBRADOR</h3>
        <div class="debug-row"><span>ANCHO (X):</span> <input type="range" id="sl-x" min="0.5" max="3" step="0.05" value="1.1"> <span id="val-x">1.1</span></div>
        <div class="debug-row"><span>ALTURA (Y):</span> <input type="range" id="sl-y" min="-2" max="2" step="0.05" value="0.3"> <span id="val-y">0.3</span></div>
        <div class="debug-row"><span>LARGO (Z):</span> <input type="range" id="sl-z" min="0.5" max="3" step="0.05" value="1.6"> <span id="val-z">1.6</span></div>
        <div class="debug-row"><span>VISUAL Y:</span> <input type="range" id="sl-vy" min="-2" max="2" step="0.05" value="-0.5"> <span id="val-vy">-0.5</span></div>
        <div class="debug-row"><span>ROT RUEDA X:</span> <input type="range" id="sl-rx" min="0" max="6.28" step="1.57" value="0"> <span id="val-rx">0</span></div>
        <div class="debug-row"><span>ROT RUEDA Z:</span> <input type="range" id="sl-rz" min="0" max="6.28" step="1.57" value="0"> <span id="val-rz">0</span></div>
        <button onclick="copiarConfig()" style="margin-top:5px; cursor:pointer;">COPIAR DATOS A CONSOLA</button>
    </div>

    <div id="ui-layer">
        <div id="speed-box">0 KM/H</div>
        <div class="controls-area">
            <div id="steering-zone"></div>
            <div style="display:flex; gap:10px;">
                <div id="brake-pedal" class="pedal"></div>
                <div id="gas-pedal" class="pedal"></div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

        // ==========================================
        //  CONFIGURACIÓN INICIAL (Modificar Scale)
        // ==========================================
        const SCALE_FACTOR = 1.0; 
        const ARCHIVO_CHASIS = 'chasis.fbx';
        const ARCHIVO_RUEDA  = 'rueda.fbx';
        // ==========================================

        // Variables de calibración en tiempo real
        const cal = { x: 1.1, y: 0.3, z: 1.6, visualY: -0.5, rotX: 0, rotZ: 0 };

        // Inputs
        const controls = { gas:0, brake:0, steer:0 };
        const inputs = { key:{gas:0, brake:0, steer:0}, touch:{gas:0, brake:0, steer:0} };

        // Scene
        const scene = new THREE.Scene(); scene.background = new THREE.Color(0x333);
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        const sun = new THREE.DirectionalLight(0xffffff, 2); sun.position.set(10, 20, 10); scene.add(sun);
        scene.add(new THREE.AmbientLight(0xffffff, 0.8));

        // Physics
        const world = new CANNON.World(); world.gravity.set(0, -9.82, 0); world.broadphase = new CANNON.SAPBroadphase(world);
        const groundMat = new CANNON.Material(); const wheelMat = new CANNON.Material();
        world.addContactMaterial(new CANNON.ContactMaterial(wheelMat, groundMat, { friction: 3, restitution: 0 }));
        
        const gb = new CANNON.Body({ mass: 0, material: groundMat });
        gb.addShape(new CANNON.Plane()); gb.quaternion.setFromEuler(-Math.PI/2, 0, 0); world.addBody(gb);
        scene.add(new THREE.GridHelper(100, 100));

        // --- CARGADORES ---
        const fbxLoader = new FBXLoader();
        const chassisGroup = new THREE.Group();
        const wheelVisuals = []; // Array de { container: Group, mesh: Mesh }

        // 1. CHASIS
        fbxLoader.load(`./models/${ARCHIVO_CHASIS}`, (obj) => {
            obj.scale.set(SCALE_FACTOR, SCALE_FACTOR, SCALE_FACTOR);
            obj.rotation.y = Math.PI; // Mirar al frente por defecto
            chassisGroup.add(obj);
        });
        scene.add(chassisGroup);

        // 2. RUEDA (CON AUTO-CENTRADO GEOMÉTRICO)
        fbxLoader.load(`./models/${ARCHIVO_RUEDA}`, (raw) => {
            // A. Encontrar la geometría real dentro del FBX
            let mesh = null;
            raw.traverse(c => { if(c.isMesh && !mesh) mesh = c; }); // Tomar la primera malla encontrada

            if(mesh) {
                // B. Calcular el centro geométrico de esa malla
                mesh.geometry.computeBoundingBox();
                const center = new THREE.Vector3();
                mesh.geometry.boundingBox.getCenter(center);
                
                // C. Negar el centro para que (0,0,0) sea el centro real
                mesh.geometry.translate(-center.x, -center.y, -center.z);
                
                // D. Clonar 4 veces
                for(let i=0; i<4; i++) {
                    // Contenedor que sigue a la física
                    const wheelContainer = new THREE.Group(); 
                    
                    // Clonamos la malla corregida
                    const wMesh = new THREE.Mesh(mesh.geometry, mesh.material);
                    wMesh.scale.set(SCALE_FACTOR, SCALE_FACTOR, SCALE_FACTOR);
                    wMesh.castShadow = true;

                    // Guardamos referencia para rotarla con el slider
                    wheelContainer.add(wMesh);
                    scene.add(wheelContainer);
                    
                    wheelVisuals.push({ container: wheelContainer, mesh: wMesh });
                }
            } else {
                console.error("No se encontró malla en la rueda FBX");
            }
        });

        // --- FÍSICAS ---
        const chassisBody = new CANNON.Body({ mass: 150, material: groundMat });
        chassisBody.addShape(new CANNON.Box(new CANNON.Vec3(0.8*SCALE_FACTOR, 0.2*SCALE_FACTOR, 2.2*SCALE_FACTOR)), new CANNON.Vec3(0, 0.5, 0));
        chassisBody.position.set(0, 3, 0); chassisBody.angularDamping = 0.5;

        const vehicle = new CANNON.RaycastVehicle({ chassisBody: chassisBody, indexRightAxis: 0, indexUpAxis: 1, indexForwardAxis: 2 });
        const wOpts = { radius: 0.4 * SCALE_FACTOR, directionLocal: new CANNON.Vec3(0,-1,0), suspensionStiffness: 45, suspensionRestLength: 0.5, frictionSlip: 4, dampingRelaxation: 2.3, dampingCompression: 4.4, maxSuspensionForce: 100000, axleLocal: new CANNON.Vec3(-1,0,0), chassisConnectionPointLocal: new CANNON.Vec3(0,0,0), maxSuspensionTravel: 0.3, useCustomSlidingRotationalSpeed: true, customSlidingRotationalSpeed: -30 };

        // Añadir 4 ruedas (posiciones placeholder, se actualizarán en el loop con los sliders)
        for(let i=0; i<4; i++) {
            vehicle.addWheel(wOpts);
        }
        vehicle.addToWorld(world);

        // --- INPUT HANDLING ---
        window.onkeydown = (e) => {
            const k = e.key.toLowerCase();
            if(k==='w') inputs.key.gas=1; if(k==='s') inputs.key.brake=1;
            if(k==='a') inputs.key.steer=1; if(k==='d') inputs.key.steer=-1;
        };
        window.onkeyup = (e) => {
            const k = e.key.toLowerCase();
            if(k==='w') inputs.key.gas=0; if(k==='s') inputs.key.brake=0;
            if(k==='a'||k==='d') inputs.key.steer=0;
        };

        // --- UPDATER DE SLIDERS ---
        function updateCalibration() {
            cal.x = parseFloat(document.getElementById('sl-x').value);
            cal.y = parseFloat(document.getElementById('sl-y').value);
            cal.z = parseFloat(document.getElementById('sl-z').value);
            cal.visualY = parseFloat(document.getElementById('sl-vy').value);
            cal.rotX = parseFloat(document.getElementById('sl-rx').value);
            cal.rotZ = parseFloat(document.getElementById('sl-rz').value);

            // Actualizar etiquetas
            document.getElementById('val-x').innerText = cal.x;
            document.getElementById('val-y').innerText = cal.y;
            document.getElementById('val-z').innerText = cal.z;
            document.getElementById('val-vy').innerText = cal.visualY;
            document.getElementById('val-rx').innerText = (cal.rotX * 57.29).toFixed(0) + "°";
            document.getElementById('val-rz').innerText = (cal.rotZ * 57.29).toFixed(0) + "°";

            // Actualizar Físicas (Posiciones de ruedas)
            // Delanteras
            vehicle.wheelInfos[0].chassisConnectionPointLocal.set(cal.x, cal.y, cal.z);
            vehicle.wheelInfos[1].chassisConnectionPointLocal.set(-cal.x, cal.y, cal.z);
            // Traseras
            vehicle.wheelInfos[2].chassisConnectionPointLocal.set(cal.x, cal.y, -cal.z);
            vehicle.wheelInfos[3].chassisConnectionPointLocal.set(-cal.x, cal.y, -cal.z);

            // Actualizar Visual Chasis
            chassisGroup.position.y = cal.visualY;

            // Actualizar Rotación Interna de Ruedas (Para arreglar lo pandeado)
            wheelVisuals.forEach(w => {
                if(w.mesh) w.mesh.rotation.set(cal.rotX, 0, cal.rotZ);
            });
        }

        window.copiarConfig = function() {
            console.log(`
            // --- COPIA ESTO EN TU CÓDIGO ---
            const SEPARACION_ANCHO = ${cal.x};
            const ALTURA_SUSPENSION = ${cal.y};
            const SEPARACION_LARGO = ${cal.z};
            const VISUAL_OFFSET_Y = ${cal.visualY};
            const WHEEL_ROT_X = ${cal.rotX};
            const WHEEL_ROT_Z = ${cal.rotZ};
            `);
            alert("Configuración copiada en la consola (F12)");
        };

        // --- ANIMATION ---
        function animate() {
            requestAnimationFrame(animate);
            updateCalibration(); // Leer sliders cada frame

            // Inputs
            const gas = inputs.key.gas; // + touch logic here if needed
            const brake = inputs.key.brake;
            const steer = inputs.key.steer;

            const force = 2000;
            vehicle.applyEngineForce(-gas * force, 2); vehicle.applyEngineForce(-gas * force, 3);
            vehicle.setBrake(brake * 100, 0); vehicle.setBrake(brake * 100, 1);
            vehicle.setBrake(brake * 100, 2); vehicle.setBrake(brake * 100, 3);
            vehicle.setSteeringValue(steer * 0.6, 0); vehicle.setSteeringValue(steer * 0.6, 1);

            world.fixedStep();

            // Sync
            chassisGroup.position.copy(chassisBody.position);
            chassisGroup.position.y += cal.visualY; // Offset visual manual
            chassisGroup.quaternion.copy(chassisBody.quaternion);

            for(let i=0; i<4; i++){
                vehicle.updateWheelTransform(i);
                if(wheelVisuals[i]) {
                    // El contenedor sigue a la física
                    wheelVisuals[i].container.position.copy(vehicle.wheelInfos[i].worldTransform.position);
                    wheelVisuals[i].container.quaternion.copy(vehicle.wheelInfos[i].worldTransform.quaternion);
                }
            }

            // Camera
            const target = new THREE.Vector3(0, 3, -7).applyMatrix4(chassisGroup.matrixWorld);
            camera.position.lerp(target, 0.1);
            camera.lookAt(chassisGroup.position);

            document.getElementById('speed-val').innerText = Math.floor(chassisBody.velocity.length() * 3.6);
            renderer.render(scene, camera);
        }
        animate();
        window.onresize=()=>{renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();};

    </script>
</body>
</html>
